\hypertarget{a00040}{\section{Yarn.\-Parser.\-Expression Class Reference}
\label{a00040}\index{Yarn.\-Parser.\-Expression@{Yarn.\-Parser.\-Expression}}
}


Inheritance diagram for Yarn.\-Parser.\-Expression\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=214pt]{a00264}
\end{center}
\end{figure}


Collaboration diagram for Yarn.\-Parser.\-Expression\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=350pt]{a00265}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
override string \hyperlink{a00063_a18c67cb16090d0889bb9d6c8c6c565f8}{To\-String} ()
\end{DoxyCompactItemize}
\subsection*{Package Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{a00040_aceddb5496ccffe668bced2d131e4bf86}{Type} \{ \hyperlink{a00040_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}{Type.\-Value}, 
\hyperlink{a00040_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}{Type.\-Function\-Call}
 \}
\end{DoxyCompactItemize}
\subsection*{Package Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{a00040_a91f0536300ebb39eaf9b7526c7e97364}{Expression} (\hyperlink{a00063}{Parse\-Node} \hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, \hyperlink{a00087}{Value\-Node} \hyperlink{a00040_a569e516782891544c334ff8131b23108}{value})
\item 
\hyperlink{a00040_ac2a8b8fd554b8006b5e2f1d1ca3cf93e}{Expression} (\hyperlink{a00063}{Parse\-Node} \hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, \hyperlink{a00041}{Function\-Info} \hyperlink{a00040_a9c1859ce5ad4c86ded8dd0d61da61320}{function}, List$<$ \hyperlink{a00040}{Expression} $>$ \hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters})
\item 
override string \hyperlink{a00040_a509ba6d93218203bae56a5a7a82e8261}{Print\-Tree} (int indent\-Level)
\item 
\hyperlink{a00054}{Node} \hyperlink{a00063_a580e520a29444fc23ac3660cbe514a09}{Node\-Parent} ()
\end{DoxyCompactItemize}
\subsection*{Static Package Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{a00040}{Expression} \hyperlink{a00040_a686da57aaf67d50d2832f9ee0028a979}{Parse} (\hyperlink{a00063}{Parse\-Node} \hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, \hyperlink{a00064}{Parser} p)
\end{DoxyCompactItemize}
\subsection*{Package Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{a00040_aceddb5496ccffe668bced2d131e4bf86}{Type} \hyperlink{a00040_ad55c92df835006328bc2a79a8f91efb9}{type}
\item 
\hyperlink{a00087}{Value\-Node} \hyperlink{a00040_a569e516782891544c334ff8131b23108}{value}
\item 
\hyperlink{a00041}{Function\-Info} \hyperlink{a00040_a9c1859ce5ad4c86ded8dd0d61da61320}{function}
\item 
List$<$ \hyperlink{a00040}{Expression} $>$ \hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters}
\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{a00040_a5004a8eaa00b2b55856ecb4f339033fb}{Should\-Apply\-Precedence} (\hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{Token\-Type} o1, Stack$<$ \hyperlink{a00079}{Token} $>$ operator\-Stack)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Member Enumeration Documentation}
\hypertarget{a00040_aceddb5496ccffe668bced2d131e4bf86}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Type@{Type}}
\index{Type@{Type}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Yarn.\-Parser.\-Expression.\-Type}\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_aceddb5496ccffe668bced2d131e4bf86}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{Value@{Value}!Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}}\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Value@{Value}}\item[{\em 
\hypertarget{a00040_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}{Value}\label{a00040_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}
}]\index{Function\-Call@{Function\-Call}!Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}}\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Function\-Call@{Function\-Call}}\item[{\em 
\hypertarget{a00040_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}{Function\-Call}\label{a00040_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
737                                \{
738                 \hyperlink{a00040_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}{Value},
739                 \hyperlink{a00040_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}{FunctionCall}
740             \}
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{a00040_a91f0536300ebb39eaf9b7526c7e97364}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Expression@{Expression}}
\index{Expression@{Expression}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Expression}]{\setlength{\rightskip}{0pt plus 5cm}Yarn.\-Parser.\-Expression.\-Expression (
\begin{DoxyParamCaption}
\item[{{\bf Parse\-Node}}]{parent, }
\item[{{\bf Value\-Node}}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_a91f0536300ebb39eaf9b7526c7e97364}

\begin{DoxyCode}
749                                                                    : base(\hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, null) \{
750                 this.type = Type.Value;
751                 this.value = \hyperlink{a00040_a569e516782891544c334ff8131b23108}{value};
752             \}
\end{DoxyCode}
\hypertarget{a00040_ac2a8b8fd554b8006b5e2f1d1ca3cf93e}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Expression@{Expression}}
\index{Expression@{Expression}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Expression}]{\setlength{\rightskip}{0pt plus 5cm}Yarn.\-Parser.\-Expression.\-Expression (
\begin{DoxyParamCaption}
\item[{{\bf Parse\-Node}}]{parent, }
\item[{{\bf Function\-Info}}]{function, }
\item[{List$<$ {\bf Expression} $>$}]{parameters}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_ac2a8b8fd554b8006b5e2f1d1ca3cf93e}

\begin{DoxyCode}
754                                                                                                       : 
      base(\hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, null) \{
755                 \hyperlink{a00040_ad55c92df835006328bc2a79a8f91efb9}{type} = Type.FunctionCall;
756                 this.function = \textcolor{keyword}{function};
757                 this.parameters = \hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters};
758             \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{a00063_a580e520a29444fc23ac3660cbe514a09}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Node\-Parent@{Node\-Parent}}
\index{Node\-Parent@{Node\-Parent}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Node\-Parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Node} Yarn.\-Parser.\-Parse\-Node.\-Node\-Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [inherited]}}}\label{a00063_a580e520a29444fc23ac3660cbe514a09}

\begin{DoxyCode}
116                                        \{
117                 var node = \textcolor{keyword}{this};
118 
119                 \textcolor{keywordflow}{do} \{
120                     \textcolor{keywordflow}{if} (node is Node) \{
121                         \textcolor{keywordflow}{return} node as Node;
122                     \}
123                     node = node.parent;
124                 \} \textcolor{keywordflow}{while} (node 
125                     != null);                   
126 
127                 \textcolor{keywordflow}{return} null;
128             \}
\end{DoxyCode}
\hypertarget{a00040_a686da57aaf67d50d2832f9ee0028a979}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Parse@{Parse}}
\index{Parse@{Parse}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Parse}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Expression} Yarn.\-Parser.\-Expression.\-Parse (
\begin{DoxyParamCaption}
\item[{{\bf Parse\-Node}}]{parent, }
\item[{{\bf Parser}}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [package]}}}\label{a00040_a686da57aaf67d50d2832f9ee0028a979}

\begin{DoxyCode}
760                                                                          \{
761 
762                 \textcolor{comment}{// Applies Djikstra's "shunting-yard" algorithm to convert the }
763                 \textcolor{comment}{// stream of infix expressions into postfix notation; we then}
764                 \textcolor{comment}{// build a tree of expressions from the result}
765 
766                 \textcolor{comment}{// https://en.wikipedia.org/wiki/Shunting-yard\_algorithm}
767 
768                 Queue<Token> \_expressionRPN = \textcolor{keyword}{new} Queue<Token> ();
769                 var operatorStack = \textcolor{keyword}{new} Stack<Token>();
770 
771                 \textcolor{comment}{// used for keeping count of parameters for each function}
772                 var functionStack = \textcolor{keyword}{new} Stack<Token> (); 
773 
774                 var allValidTokenTypes = \textcolor{keyword}{new} List<TokenType>(
      \hyperlink{a00058_a8dca7db3b76b8c358aba6068274e07df}{Operator.operatorTypes});
775                 allValidTokenTypes.Add(TokenType.Number);
776                 allValidTokenTypes.Add(TokenType.Variable);
777                 allValidTokenTypes.Add(TokenType.String);
778                 allValidTokenTypes.Add(TokenType.LeftParen);
779                 allValidTokenTypes.Add(TokenType.RightParen);
780                 allValidTokenTypes.Add(TokenType.Identifier);
781                 allValidTokenTypes.Add(TokenType.Comma);
782                 allValidTokenTypes.Add(TokenType.True);
783                 allValidTokenTypes.Add(TokenType.False);
784                 allValidTokenTypes.Add(TokenType.Null);
785 
786                 Token lastToken = null;
787 
788                 \textcolor{comment}{// Read all the contents of the expression}
789                 \textcolor{keywordflow}{while} (p.tokens.Count > 0 && p.NextSymbolIs(allValidTokenTypes.ToArray())) \{
790 
791                     Token nextToken = p.ExpectSymbol(allValidTokenTypes.ToArray());
792 
793                     \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Number ||
794                         nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Variable ||
795                         nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.String ||
796                         nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.True ||
797                         nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.False ||
798                         nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Null) \{
799 
800                         \textcolor{comment}{// Primitive values go straight onto the output}
801                         \_expressionRPN.Enqueue (nextToken);
802                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Identifier) \{
803                         operatorStack.Push (nextToken);
804                         functionStack.Push (nextToken);
805 
806                         \textcolor{comment}{// next token must be a left paren, so process that immediately}
807                         nextToken = p.ExpectSymbol (TokenType.LeftParen);
808                         \textcolor{comment}{// enter that sub-expression}
809                         operatorStack.Push (nextToken);
810 
811                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Comma) \{
812 
813                         \textcolor{comment}{// Resolve this sub-expression before moving on to the}
814                         \textcolor{comment}{// next parameter}
815                         \textcolor{keywordflow}{try} \{
816                             \textcolor{comment}{// pop operators until we reach a left paren}
817                             \textcolor{keywordflow}{while} (operatorStack.Peek().type != TokenType.LeftParen) \{
818                                 \_expressionRPN.Enqueue(operatorStack.Pop());
819                             \}
820                         \} \textcolor{keywordflow}{catch} (InvalidOperationException) \{
821                             \textcolor{comment}{// we reached the end of the stack prematurely}
822                             \textcolor{comment}{// this means unbalanced parens!}
823                             \textcolor{keywordflow}{throw} ParseException.Make(nextToken, \textcolor{stringliteral}{"Error parsing expression: "} +
824                                 \textcolor{stringliteral}{"unbalanced parentheses"});
825                         \}
826 
827                         \textcolor{comment}{// We expect the top of the stack to now contain the left paren that }
828                         \textcolor{comment}{// began the list of parameters}
829                         \textcolor{keywordflow}{if} (operatorStack.Peek().type != TokenType.LeftParen) \{
830                             \textcolor{keywordflow}{throw} ParseException.Make (operatorStack.Peek (), \textcolor{stringliteral}{"Expression parser got "} +
831                                 \textcolor{stringliteral}{"confused dealing with a function"});
832                         \}
833 
834                         \textcolor{comment}{// The next token is not allowed to be a right-paren or a comma}
835                         \textcolor{comment}{// (that is, you can't say "foo(2,,)")}
836                         \textcolor{keywordflow}{if} (p.NextSymbolIs(\hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.RightParen, 
      \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Comma)) \{
837                             \textcolor{keywordflow}{throw} ParseException.Make (p.tokens.Peek(), \textcolor{stringliteral}{"Expected expression"});
838                         \}
839 
840                         \textcolor{comment}{// Find the closest function on the stack}
841                         \textcolor{comment}{// and increment the number of parameters}
842                         functionStack.Peek().parameterCount++;
843 
844                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Operator.IsOperator(nextToken.type)) \{
845                         \textcolor{comment}{// This is an operator}
846 
847                         \textcolor{comment}{// If this is a Minus, we need to determine if it's a }
848                         \textcolor{comment}{// unary minus or a binary minus.}
849                         \textcolor{comment}{// Unary minus looks like this: "-1"}
850                         \textcolor{comment}{// Binary minus looks like this: "2 - 3"}
851                         \textcolor{comment}{// Things get complex when we say stuff like "1 + -1".}
852                         \textcolor{comment}{// But it's easier when we realise that a minus}
853                         \textcolor{comment}{// is ONLY unary when the last token was a left paren,}
854                         \textcolor{comment}{// an operator, or it's the first token.}
855 
856                         \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Minus) \{
857 
858                             \textcolor{keywordflow}{if} (lastToken == null || 
859                                 lastToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.LeftParen ||
860                                 Operator.IsOperator(lastToken.type)) \{
861 
862                                 \textcolor{comment}{// This is actually a unary minus.}
863                                 nextToken.type = TokenType.UnaryMinus;
864                             \}
865                         \}
866 
867                         \textcolor{comment}{// We cannot assign values inside an expression. That is,}
868                         \textcolor{comment}{// saying "$foo = 2" in an express does not assign $foo to 2}
869                         \textcolor{comment}{// and then evaluate to 2. Instead, Yarn defines this}
870                         \textcolor{comment}{// to mean "$foo == 2"}
871                         \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.EqualToOrAssign) \{
872                             nextToken.type = TokenType.EqualTo;
873                         \}
874 
875                         \textcolor{comment}{// O1 = this operator}
876                         \textcolor{comment}{// O2 = the token at the top of the stack}
877                         \textcolor{comment}{// While O2 is an operator, and EITHER: 1. O1 is left-associative and}
878                         \textcolor{comment}{// has precedence <= O2, or 2. O1 is right-associative and}
879                         \textcolor{comment}{// has precedence > O2:}
880                         \textcolor{keywordflow}{while} (\hyperlink{a00040_a5004a8eaa00b2b55856ecb4f339033fb}{ShouldApplyPrecedence}(nextToken.type, operatorStack)) \{
881                             var o = operatorStack.Pop();
882                             \_expressionRPN.Enqueue(o);
883                         \}
884                         operatorStack.Push(nextToken);
885 
886                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.LeftParen) \{
887 
888                         \textcolor{comment}{// Record that we have entered a paren-delimited}
889                         \textcolor{comment}{// subexpression}
890                         operatorStack.Push(nextToken);
891                         
892                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.RightParen) \{
893 
894                         \textcolor{comment}{// We're leaving a subexpression; time to resolve the}
895                         \textcolor{comment}{// order of operations that we saw in between the parens.}
896 
897                         \textcolor{keywordflow}{try} \{
898                             \textcolor{comment}{// pop operators until we reach a left paren}
899                             \textcolor{keywordflow}{while} (operatorStack.Peek().type != TokenType.LeftParen) \{
900                                 \_expressionRPN.Enqueue(operatorStack.Pop());
901                             \}
902                             \textcolor{comment}{// pop the left paren}
903                             operatorStack.Pop();
904                         \} \textcolor{keywordflow}{catch} (InvalidOperationException) \{
905                             \textcolor{comment}{// we reached the end of the stack prematurely}
906                             \textcolor{comment}{// this means unbalanced parens!}
907                             \textcolor{keywordflow}{throw} ParseException.Make(nextToken, \textcolor{stringliteral}{"Error parsing expression: unbalanced
       parentheses"});
908                         \}
909 
910                         \textcolor{keywordflow}{if} (operatorStack.Peek().type == TokenType.Identifier) \{
911                             \textcolor{comment}{// This whole paren-delimited subexpression is actually}
912                             \textcolor{comment}{// a function call}
913 
914                             \textcolor{comment}{// If the last token was a left-paren, then this}
915                             \textcolor{comment}{// was a function with no parameters; otherwise, we }
916                             \textcolor{comment}{// have an additional parameter (on top of the ones we counted}
917                             \textcolor{comment}{// while encountering commas)}
918 
919                             \textcolor{keywordflow}{if} (lastToken.type != \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.LeftParen) \{
920                                 functionStack.Peek ().parameterCount++;
921                             \}
922 
923                             \_expressionRPN.Enqueue(operatorStack.Pop());
924                             functionStack.Pop ();
925                         \}
926 
927                     \}
928 
929                     \textcolor{comment}{// Record this as the last token we saw; we'll use}
930                     \textcolor{comment}{// this to figure out if minuses are unary or not}
931                     lastToken = nextToken;
932 
933                 \}
934 
935                 \textcolor{comment}{// No more tokens; pop all operators onto the output queue}
936                 \textcolor{keywordflow}{while} (operatorStack.Count > 0) \{
937                     \_expressionRPN.Enqueue(operatorStack.Pop());
938                 \}
939 
940                 \textcolor{comment}{// If the output queue is empty, then this is not an expression}
941                 \textcolor{keywordflow}{if} (\_expressionRPN.Count == 0) \{
942                     \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException (\textcolor{stringliteral}{"Error parsing expression: no expression found!"});
943                 \}
944 
945                 \textcolor{comment}{// We've now got this in more easily parsed RPN form; }
946                 \textcolor{comment}{// time to build the expression tree.}
947                 Token firstToken = \_expressionRPN.Peek();
948                 var evaluationStack = \textcolor{keyword}{new} Stack<Expression>();
949                 \textcolor{keywordflow}{while} (\_expressionRPN.Count > 0) \{
950 
951                     var next = \_expressionRPN.Dequeue();
952                     \textcolor{keywordflow}{if} (Operator.IsOperator(next.type)) \{
953 
954                         \textcolor{comment}{// This is an operation}
955 
956                         var info = Operator.InfoForOperator(next.type);
957                         \textcolor{keywordflow}{if} (evaluationStack.Count < info.arguments) \{
958                             \textcolor{keywordflow}{throw} ParseException.Make(next, \textcolor{stringliteral}{"Error parsing expression: not enough "} +
959                                 \textcolor{stringliteral}{"arguments for operator "}+next.type.ToString());
960                         \}
961 
962                         var \hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters} = \textcolor{keyword}{new} List<Expression> ();
963 
964                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < info.arguments; i++) \{
965                             parameters.Add (evaluationStack.Pop ());
966                         \}
967                         parameters.Reverse ();
968 
969                         var operatorFunc = p.library.GetFunction (next.type.ToString());
970 
971                         var expr = \textcolor{keyword}{new} \hyperlink{a00040_a91f0536300ebb39eaf9b7526c7e97364}{Expression} (\hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, operatorFunc, 
      \hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters});
972 
973                         evaluationStack.Push(expr);
974                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next.type == \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Identifier) \{
975                         \textcolor{comment}{// This is a function call}
976                         var info = p.library.GetFunction(next.value as \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeacea27118326006d3829667a400ad23d5d98}{String});
977 
978                         \textcolor{comment}{// Ensure that this call has the right number of params}
979                         \textcolor{keywordflow}{if} (info.IsParameterCountCorrect(next.parameterCount) == \textcolor{keyword}{false}) \{
980                             \textcolor{keywordtype}{string} error = string.Format(\textcolor{stringliteral}{"Error parsing expression: "} +
981                                 \textcolor{stringliteral}{"Unsupported number of parameters for function \{0\} (expected \{1\}, got \{2\})"}
      ,
982                                 next.value as \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeacea27118326006d3829667a400ad23d5d98}{String},
983                                 info.paramCount,
984                                 next.parameterCount
985                             );
986                             \textcolor{keywordflow}{throw} ParseException.Make(next, error);
987                         \}
988 
989                         var parameterList = \textcolor{keyword}{new} List<Expression> ();
990                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < next.parameterCount; i++) \{
991                             parameterList.Add (evaluationStack.Pop());
992                         \}
993                         parameterList.Reverse ();
994 
995                         var expr = \textcolor{keyword}{new} \hyperlink{a00040_a91f0536300ebb39eaf9b7526c7e97364}{Expression} (\hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, info, parameterList);
996 
997                         evaluationStack.Push (expr);
998 
999                     \} \textcolor{keywordflow}{else} \{
1000 
1001                         \textcolor{comment}{// This is a raw value}
1002                         var v = \textcolor{keyword}{new} ValueNode(\hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, next);
1003                         \hyperlink{a00040_a91f0536300ebb39eaf9b7526c7e97364}{Expression} expr = \textcolor{keyword}{new} \hyperlink{a00040_a91f0536300ebb39eaf9b7526c7e97364}{Expression}(
      \hyperlink{a00063_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, v);
1004                         evaluationStack.Push(expr);
1005 
1006                     \}
1007                 \}
1008                 \textcolor{comment}{// We should now have a single expression in this stack, which is the root}
1009                 \textcolor{comment}{// of the expression's tree. If we have more than one, then we have a problem.}
1010                 \textcolor{keywordflow}{if} (evaluationStack.Count != 1) \{
1011                     \textcolor{keywordflow}{throw} ParseException.Make(firstToken, \textcolor{stringliteral}{"Error parsing expression "} +
1012                         \textcolor{stringliteral}{"(stack did not reduce correctly)"});
1013                 \}
1014 
1015                 \textcolor{comment}{// Return it}
1016                 \textcolor{keywordflow}{return} evaluationStack.Pop ();
1017 
1018 
1019             \}
\end{DoxyCode}
\hypertarget{a00040_a509ba6d93218203bae56a5a7a82e8261}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Print\-Tree@{Print\-Tree}}
\index{Print\-Tree@{Print\-Tree}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Print\-Tree}]{\setlength{\rightskip}{0pt plus 5cm}override string Yarn.\-Parser.\-Expression.\-Print\-Tree (
\begin{DoxyParamCaption}
\item[{int}]{indent\-Level}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [virtual]}}}\label{a00040_a509ba6d93218203bae56a5a7a82e8261}


Implements \hyperlink{a00063_a0d6611653f20c2e4d90a97a96c657137}{Yarn.\-Parser.\-Parse\-Node}.


\begin{DoxyCode}
1051             \{
1052                 var stringBuilder = \textcolor{keyword}{new} StringBuilder ();
1053                 \textcolor{keywordflow}{switch} (\hyperlink{a00040_ad55c92df835006328bc2a79a8f91efb9}{type}) \{
1054                 \textcolor{keywordflow}{case} Type.Value:
1055                     \textcolor{keywordflow}{return} value.PrintTree (indentLevel);
1056                 \textcolor{keywordflow}{case} Type.FunctionCall:
1057                     
1058                     \textcolor{keywordflow}{if} (\hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters}.Count == 0) \{
1059                         stringBuilder.Append(\hyperlink{a00064_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"Function call to "} + \textcolor{keyword}{function}.name + \textcolor{stringliteral}{"
       (no parameters)"}));
1060                     \} \textcolor{keywordflow}{else} \{
1061                         stringBuilder.Append(\hyperlink{a00064_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"Function call to "} + \textcolor{keyword}{function}.name + \textcolor{stringliteral}{" ("}
       +\hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters}.Count+\textcolor{stringliteral}{" parameters) \{"}));
1062                         \textcolor{keywordflow}{foreach} (var param \textcolor{keywordflow}{in} \hyperlink{a00040_a7b21380bead8ae08b2cfc6594edab32c}{parameters}) \{
1063                             stringBuilder.Append(param.PrintTree(indentLevel+1));
1064                         \}
1065                         stringBuilder.Append(\hyperlink{a00064_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"\}"}));
1066                     \}
1067                     \textcolor{keywordflow}{return} stringBuilder.ToString();
1068 
1069 
1070                 \}
1071 
1072                 \textcolor{keywordflow}{return} \hyperlink{a00064_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"<error printing expression!>"});
1073             \}
\end{DoxyCode}
\hypertarget{a00040_a5004a8eaa00b2b55856ecb4f339033fb}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Should\-Apply\-Precedence@{Should\-Apply\-Precedence}}
\index{Should\-Apply\-Precedence@{Should\-Apply\-Precedence}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Should\-Apply\-Precedence}]{\setlength{\rightskip}{0pt plus 5cm}static bool Yarn.\-Parser.\-Expression.\-Should\-Apply\-Precedence (
\begin{DoxyParamCaption}
\item[{{\bf Token\-Type}}]{o1, }
\item[{Stack$<$ {\bf Token} $>$}]{operator\-Stack}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}}\label{a00040_a5004a8eaa00b2b55856ecb4f339033fb}

\begin{DoxyCode}
1023                                                                                                 \{
1024                 
1025                 \textcolor{keywordflow}{if} (operatorStack.Count == 0) \{
1026                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1027                 \}
1028                 \textcolor{keywordflow}{if} (Operator.IsOperator (o1) == \textcolor{keyword}{false}) \{
1029                     \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException (\textcolor{stringliteral}{"Internal error parsing expression"});
1030                 \}
1031                 \hyperlink{a00026_a301aa7c866593a5b625a8fc158bbeace}{TokenType} o2 = operatorStack.Peek ().\hyperlink{a00040_ad55c92df835006328bc2a79a8f91efb9}{type};
1032 
1033                 \textcolor{keywordflow}{if} (Operator.IsOperator (o2) == \textcolor{keyword}{false})
1034                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1035 
1036                 var o1Info = Operator.InfoForOperator (o1);
1037                 var o2Info = Operator.InfoForOperator (o2);
1038 
1039                 \textcolor{keywordflow}{if} (o1Info.associativity == Operator.Associativity.Left && o1Info.precedence <= o2Info.
      precedence) \{
1040                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1041                 \}
1042 
1043                 \textcolor{keywordflow}{if} (o1Info.associativity == Operator.Associativity.Right && o1Info.precedence < o2Info.
      precedence) \{
1044                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1045                 \}
1046 
1047                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1048             \}
\end{DoxyCode}
\hypertarget{a00063_a18c67cb16090d0889bb9d6c8c6c565f8}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!To\-String@{To\-String}}
\index{To\-String@{To\-String}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{To\-String}]{\setlength{\rightskip}{0pt plus 5cm}override string Yarn.\-Parser.\-Parse\-Node.\-To\-String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}}\label{a00063_a18c67cb16090d0889bb9d6c8c6c565f8}

\begin{DoxyCode}
111             \{
112                 \textcolor{keywordflow}{return} this.GetType ().Name;
113             \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{a00040_a9c1859ce5ad4c86ded8dd0d61da61320}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!function@{function}}
\index{function@{function}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{function}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Function\-Info} Yarn.\-Parser.\-Expression.\-function\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_a9c1859ce5ad4c86ded8dd0d61da61320}
\hypertarget{a00040_a7b21380bead8ae08b2cfc6594edab32c}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!parameters@{parameters}}
\index{parameters@{parameters}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{parameters}]{\setlength{\rightskip}{0pt plus 5cm}List$<${\bf Expression}$>$ Yarn.\-Parser.\-Expression.\-parameters\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_a7b21380bead8ae08b2cfc6594edab32c}
\hypertarget{a00040_ad55c92df835006328bc2a79a8f91efb9}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!type@{type}}
\index{type@{type}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{type}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type} Yarn.\-Parser.\-Expression.\-type\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_ad55c92df835006328bc2a79a8f91efb9}
\hypertarget{a00040_a569e516782891544c334ff8131b23108}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!value@{value}}
\index{value@{value}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{value}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Value\-Node} Yarn.\-Parser.\-Expression.\-value\hspace{0.3cm}{\ttfamily [package]}}}\label{a00040_a569e516782891544c334ff8131b23108}


The documentation for this class was generated from the following file\-:\begin{DoxyCompactItemize}
\item 
Yarn\-Spinner/\hyperlink{a00122}{Parser.\-cs}\end{DoxyCompactItemize}
