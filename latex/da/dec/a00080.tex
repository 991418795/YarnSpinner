\hypertarget{a00080}{\section{Yarn.\-Parser.\-Expression Class Reference}
\label{a00080}\index{Yarn.\-Parser.\-Expression@{Yarn.\-Parser.\-Expression}}
}


Inheritance diagram for Yarn.\-Parser.\-Expression\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=214pt]{d7/dd2/a00598}
\end{center}
\end{figure}


Collaboration diagram for Yarn.\-Parser.\-Expression\-:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=550pt]{d5/d8a/a00599}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
string \hyperlink{a00120_a054f36c80d5eeacd569a8859f599af67}{Tags\-To\-String} (int indent\-Level)
\item 
override string \hyperlink{a00120_a18c67cb16090d0889bb9d6c8c6c565f8}{To\-String} ()
\end{DoxyCompactItemize}
\subsection*{Package Types}
\begin{DoxyCompactItemize}
\item 
enum \hyperlink{a00080_aceddb5496ccffe668bced2d131e4bf86}{Type} \{ \hyperlink{a00080_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}{Type.\-Value}, 
\hyperlink{a00080_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}{Type.\-Function\-Call}
 \}
\end{DoxyCompactItemize}
\subsection*{Package Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{a00080_a17e5101d02b96d0071e7a0223e4daa3d}{Expression} (\hyperlink{a00120}{Parse\-Node} \hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, \hyperlink{a00162}{Value\-Node} \hyperlink{a00080_a569e516782891544c334ff8131b23108}{value}, \hyperlink{a00121}{Parser} p)
\item 
\hyperlink{a00080_a5047d9b3301d6c7367f8095267ea9b07}{Expression} (\hyperlink{a00120}{Parse\-Node} \hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, \hyperlink{a00082}{Function\-Info} \hyperlink{a00080_a9c1859ce5ad4c86ded8dd0d61da61320}{function}, List$<$ \hyperlink{a00080}{Expression} $>$ \hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters}, \hyperlink{a00121}{Parser} p)
\item 
override string \hyperlink{a00080_a509ba6d93218203bae56a5a7a82e8261}{Print\-Tree} (int indent\-Level)
\item 
\hyperlink{a00110}{Node} \hyperlink{a00120_a580e520a29444fc23ac3660cbe514a09}{Node\-Parent} ()
\end{DoxyCompactItemize}
\subsection*{Static Package Functions}
\begin{DoxyCompactItemize}
\item 
static \hyperlink{a00080}{Expression} \hyperlink{a00080_a686da57aaf67d50d2832f9ee0028a979}{Parse} (\hyperlink{a00120}{Parse\-Node} \hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, \hyperlink{a00121}{Parser} p)
\end{DoxyCompactItemize}
\subsection*{Package Attributes}
\begin{DoxyCompactItemize}
\item 
\hyperlink{a00080_aceddb5496ccffe668bced2d131e4bf86}{Type} \hyperlink{a00080_ad55c92df835006328bc2a79a8f91efb9}{type}
\item 
\hyperlink{a00162}{Value\-Node} \hyperlink{a00080_a569e516782891544c334ff8131b23108}{value}
\item 
\hyperlink{a00082}{Function\-Info} \hyperlink{a00080_a9c1859ce5ad4c86ded8dd0d61da61320}{function}
\item 
List$<$ \hyperlink{a00080}{Expression} $>$ \hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters}
\item 
\hyperlink{a00120}{Parse\-Node} \hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}
\item 
int \hyperlink{a00120_a18b493382de0fde5b4299c1bd2250075}{line\-Number}
\item 
string\mbox{[}$\,$\mbox{]} \hyperlink{a00120_a58b3a15788fd2d4127d73619dc6d04ae}{tags} = \{\}
\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool \hyperlink{a00080_a5004a8eaa00b2b55856ecb4f339033fb}{Should\-Apply\-Precedence} (\hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{Token\-Type} o1, Stack$<$ \hyperlink{a00147}{Token} $>$ operator\-Stack)
\end{DoxyCompactItemize}


\subsection{Detailed Description}


\subsection{Member Enumeration Documentation}
\hypertarget{a00080_aceddb5496ccffe668bced2d131e4bf86}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Type@{Type}}
\index{Type@{Type}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf Yarn.\-Parser.\-Expression.\-Type}\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_aceddb5496ccffe668bced2d131e4bf86}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{Value@{Value}!Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}}\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Value@{Value}}\item[{\em 
\hypertarget{a00080_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}{Value}\label{a00080_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}
}]\index{Function\-Call@{Function\-Call}!Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}}\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Function\-Call@{Function\-Call}}\item[{\em 
\hypertarget{a00080_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}{Function\-Call}\label{a00080_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}
}]\end{description}
\end{Desc}

\begin{DoxyCode}
802                                \{
803                 \hyperlink{a00080_aceddb5496ccffe668bced2d131e4bf86a689202409e48743b914713f96d93947c}{Value},
804                 \hyperlink{a00080_aceddb5496ccffe668bced2d131e4bf86affb017548928ab2305e7c55cb67c04ca}{FunctionCall}
805             \}
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\hypertarget{a00080_a17e5101d02b96d0071e7a0223e4daa3d}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Expression@{Expression}}
\index{Expression@{Expression}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Expression}]{\setlength{\rightskip}{0pt plus 5cm}Yarn.\-Parser.\-Expression.\-Expression (
\begin{DoxyParamCaption}
\item[{{\bf Parse\-Node}}]{parent, }
\item[{{\bf Value\-Node}}]{value, }
\item[{{\bf Parser}}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_a17e5101d02b96d0071e7a0223e4daa3d}

\begin{DoxyCode}
814                                                                              : base(
      \hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, p) \{
815                 this.type = Type.Value;
816                 this.value = \hyperlink{a00080_a569e516782891544c334ff8131b23108}{value};
817             \}
\end{DoxyCode}
\hypertarget{a00080_a5047d9b3301d6c7367f8095267ea9b07}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Expression@{Expression}}
\index{Expression@{Expression}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Expression}]{\setlength{\rightskip}{0pt plus 5cm}Yarn.\-Parser.\-Expression.\-Expression (
\begin{DoxyParamCaption}
\item[{{\bf Parse\-Node}}]{parent, }
\item[{{\bf Function\-Info}}]{function, }
\item[{List$<$ {\bf Expression} $>$}]{parameters, }
\item[{{\bf Parser}}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_a5047d9b3301d6c7367f8095267ea9b07}

\begin{DoxyCode}
819                                                                                                            
           : base(\hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, p) \{
820                 \hyperlink{a00080_ad55c92df835006328bc2a79a8f91efb9}{type} = Type.FunctionCall;
821                 this.function = \textcolor{keyword}{function};
822                 this.parameters = \hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters};
823             \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\hypertarget{a00120_a580e520a29444fc23ac3660cbe514a09}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Node\-Parent@{Node\-Parent}}
\index{Node\-Parent@{Node\-Parent}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Node\-Parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Node} Yarn.\-Parser.\-Parse\-Node.\-Node\-Parent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [inherited]}}}\label{a00120_a580e520a29444fc23ac3660cbe514a09}

\begin{DoxyCode}
144                                        \{
145                 var node = \textcolor{keyword}{this};
146 
147                 \textcolor{keywordflow}{do} \{
148                     \textcolor{keywordflow}{if} (node is Node) \{
149                         \textcolor{keywordflow}{return} node as Node;
150                     \}
151                     node = node.parent;
152                 \} \textcolor{keywordflow}{while} (node 
153                     != null);                   
154 
155                 \textcolor{keywordflow}{return} null;
156             \}
\end{DoxyCode}
\hypertarget{a00080_a686da57aaf67d50d2832f9ee0028a979}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Parse@{Parse}}
\index{Parse@{Parse}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Parse}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Expression} Yarn.\-Parser.\-Expression.\-Parse (
\begin{DoxyParamCaption}
\item[{{\bf Parse\-Node}}]{parent, }
\item[{{\bf Parser}}]{p}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [package]}}}\label{a00080_a686da57aaf67d50d2832f9ee0028a979}

\begin{DoxyCode}
825                                                                          \{
826 
827                 \textcolor{comment}{// Applies Djikstra's "shunting-yard" algorithm to convert the }
828                 \textcolor{comment}{// stream of infix expressions into postfix notation; we then}
829                 \textcolor{comment}{// build a tree of expressions from the result}
830 
831                 \textcolor{comment}{// https://en.wikipedia.org/wiki/Shunting-yard\_algorithm}
832 
833                 Queue<Token> \_expressionRPN = \textcolor{keyword}{new} Queue<Token> ();
834                 var operatorStack = \textcolor{keyword}{new} Stack<Token>();
835 
836                 \textcolor{comment}{// used for keeping count of parameters for each function}
837                 var functionStack = \textcolor{keyword}{new} Stack<Token> (); 
838 
839                 var allValidTokenTypes = \textcolor{keyword}{new} List<TokenType>(
      \hyperlink{a00115_a8dca7db3b76b8c358aba6068274e07df}{Operator.operatorTypes});
840                 allValidTokenTypes.Add(TokenType.Number);
841                 allValidTokenTypes.Add(TokenType.Variable);
842                 allValidTokenTypes.Add(TokenType.String);
843                 allValidTokenTypes.Add(TokenType.LeftParen);
844                 allValidTokenTypes.Add(TokenType.RightParen);
845                 allValidTokenTypes.Add(TokenType.Identifier);
846                 allValidTokenTypes.Add(TokenType.Comma);
847                 allValidTokenTypes.Add(TokenType.True);
848                 allValidTokenTypes.Add(TokenType.False);
849                 allValidTokenTypes.Add(TokenType.Null);
850 
851                 Token lastToken = null;
852 
853                 \textcolor{comment}{// Read all the contents of the expression}
854                 \textcolor{keywordflow}{while} (p.tokens.Count > 0 && p.NextSymbolIs(allValidTokenTypes.ToArray())) \{
855 
856                     Token nextToken = p.ExpectSymbol(allValidTokenTypes.ToArray());
857 
858                     \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Number ||
859                         nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Variable ||
860                         nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.String ||
861                         nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.True ||
862                         nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.False ||
863                         nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Null) \{
864 
865                         \textcolor{comment}{// Primitive values go straight onto the output}
866                         \_expressionRPN.Enqueue (nextToken);
867                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Identifier) \{
868                         operatorStack.Push (nextToken);
869                         functionStack.Push (nextToken);
870 
871                         \textcolor{comment}{// next token must be a left paren, so process that immediately}
872                         nextToken = p.ExpectSymbol (TokenType.LeftParen);
873                         \textcolor{comment}{// enter that sub-expression}
874                         operatorStack.Push (nextToken);
875 
876                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Comma) \{
877 
878                         \textcolor{comment}{// Resolve this sub-expression before moving on to the}
879                         \textcolor{comment}{// next parameter}
880                         \textcolor{keywordflow}{try} \{
881                             \textcolor{comment}{// pop operators until we reach a left paren}
882                             \textcolor{keywordflow}{while} (operatorStack.Peek().type != TokenType.LeftParen) \{
883                                 \_expressionRPN.Enqueue(operatorStack.Pop());
884                             \}
885                         \} \textcolor{keywordflow}{catch} (InvalidOperationException) \{
886                             \textcolor{comment}{// we reached the end of the stack prematurely}
887                             \textcolor{comment}{// this means unbalanced parens!}
888                             \textcolor{keywordflow}{throw} ParseException.Make(nextToken, \textcolor{stringliteral}{"Error parsing expression: "} +
889                                 \textcolor{stringliteral}{"unbalanced parentheses"});
890                         \}
891 
892                         \textcolor{comment}{// We expect the top of the stack to now contain the left paren that }
893                         \textcolor{comment}{// began the list of parameters}
894                         \textcolor{keywordflow}{if} (operatorStack.Peek().type != TokenType.LeftParen) \{
895                             \textcolor{keywordflow}{throw} ParseException.Make (operatorStack.Peek (), \textcolor{stringliteral}{"Expression parser got "} +
896                                 \textcolor{stringliteral}{"confused dealing with a function"});
897                         \}
898 
899                         \textcolor{comment}{// The next token is not allowed to be a right-paren or a comma}
900                         \textcolor{comment}{// (that is, you can't say "foo(2,,)")}
901                         \textcolor{keywordflow}{if} (p.NextSymbolIs(\hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.RightParen, 
      \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Comma)) \{
902                             \textcolor{keywordflow}{throw} ParseException.Make (p.tokens.Peek(), \textcolor{stringliteral}{"Expected expression"});
903                         \}
904 
905                         \textcolor{comment}{// Find the closest function on the stack}
906                         \textcolor{comment}{// and increment the number of parameters}
907                         functionStack.Peek().parameterCount++;
908 
909                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (Operator.IsOperator(nextToken.type)) \{
910                         \textcolor{comment}{// This is an operator}
911 
912                         \textcolor{comment}{// If this is a Minus, we need to determine if it's a }
913                         \textcolor{comment}{// unary minus or a binary minus.}
914                         \textcolor{comment}{// Unary minus looks like this: "-1"}
915                         \textcolor{comment}{// Binary minus looks like this: "2 - 3"}
916                         \textcolor{comment}{// Things get complex when we say stuff like "1 + -1".}
917                         \textcolor{comment}{// But it's easier when we realise that a minus}
918                         \textcolor{comment}{// is ONLY unary when the last token was a left paren,}
919                         \textcolor{comment}{// an operator, or it's the first token.}
920 
921                         \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Minus) \{
922 
923                             \textcolor{keywordflow}{if} (lastToken == null || 
924                                 lastToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.LeftParen ||
925                                 Operator.IsOperator(lastToken.type)) \{
926 
927                                 \textcolor{comment}{// This is actually a unary minus.}
928                                 nextToken.type = TokenType.UnaryMinus;
929                             \}
930                         \}
931 
932                         \textcolor{comment}{// We cannot assign values inside an expression. That is,}
933                         \textcolor{comment}{// saying "$foo = 2" in an express does not assign $foo to 2}
934                         \textcolor{comment}{// and then evaluate to 2. Instead, Yarn defines this}
935                         \textcolor{comment}{// to mean "$foo == 2"}
936                         \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.EqualToOrAssign) \{
937                             nextToken.type = TokenType.EqualTo;
938                         \}
939 
940                         \textcolor{comment}{// O1 = this operator}
941                         \textcolor{comment}{// O2 = the token at the top of the stack}
942                         \textcolor{comment}{// While O2 is an operator, and EITHER: 1. O1 is left-associative and}
943                         \textcolor{comment}{// has precedence <= O2, or 2. O1 is right-associative and}
944                         \textcolor{comment}{// has precedence > O2:}
945                         \textcolor{keywordflow}{while} (\hyperlink{a00080_a5004a8eaa00b2b55856ecb4f339033fb}{ShouldApplyPrecedence}(nextToken.type, operatorStack)) \{
946                             var o = operatorStack.Pop();
947                             \_expressionRPN.Enqueue(o);
948                         \}
949                         operatorStack.Push(nextToken);
950 
951                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.LeftParen) \{
952 
953                         \textcolor{comment}{// Record that we have entered a paren-delimited}
954                         \textcolor{comment}{// subexpression}
955                         operatorStack.Push(nextToken);
956                         
957                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (nextToken.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.RightParen) \{
958 
959                         \textcolor{comment}{// We're leaving a subexpression; time to resolve the}
960                         \textcolor{comment}{// order of operations that we saw in between the parens.}
961 
962                         \textcolor{keywordflow}{try} \{
963                             \textcolor{comment}{// pop operators until we reach a left paren}
964                             \textcolor{keywordflow}{while} (operatorStack.Peek().type != TokenType.LeftParen) \{
965                                 \_expressionRPN.Enqueue(operatorStack.Pop());
966                             \}
967                             \textcolor{comment}{// pop the left paren}
968                             operatorStack.Pop();
969                         \} \textcolor{keywordflow}{catch} (InvalidOperationException) \{
970                             \textcolor{comment}{// we reached the end of the stack prematurely}
971                             \textcolor{comment}{// this means unbalanced parens!}
972                             \textcolor{keywordflow}{throw} ParseException.Make(nextToken, \textcolor{stringliteral}{"Error parsing expression: unbalanced
       parentheses"});
973                         \}
974 
975                         \textcolor{keywordflow}{if} (operatorStack.Peek().type == TokenType.Identifier) \{
976                             \textcolor{comment}{// This whole paren-delimited subexpression is actually}
977                             \textcolor{comment}{// a function call}
978 
979                             \textcolor{comment}{// If the last token was a left-paren, then this}
980                             \textcolor{comment}{// was a function with no parameters; otherwise, we }
981                             \textcolor{comment}{// have an additional parameter (on top of the ones we counted}
982                             \textcolor{comment}{// while encountering commas)}
983 
984                             \textcolor{keywordflow}{if} (lastToken.type != \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.LeftParen) \{
985                                 functionStack.Peek ().parameterCount++;
986                             \}
987 
988                             \_expressionRPN.Enqueue(operatorStack.Pop());
989                             functionStack.Pop ();
990                         \}
991 
992                     \}
993 
994                     \textcolor{comment}{// Record this as the last token we saw; we'll use}
995                     \textcolor{comment}{// this to figure out if minuses are unary or not}
996                     lastToken = nextToken;
997 
998                 \}
999 
1000                 \textcolor{comment}{// No more tokens; pop all operators onto the output queue}
1001                 \textcolor{keywordflow}{while} (operatorStack.Count > 0) \{
1002                     \_expressionRPN.Enqueue(operatorStack.Pop());
1003                 \}
1004 
1005                 \textcolor{comment}{// If the output queue is empty, then this is not an expression}
1006                 \textcolor{keywordflow}{if} (\_expressionRPN.Count == 0) \{
1007                     \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException (\textcolor{stringliteral}{"Error parsing expression: no expression found!"});
1008                 \}
1009 
1010                 \textcolor{comment}{// We've now got this in more easily parsed RPN form; }
1011                 \textcolor{comment}{// time to build the expression tree.}
1012                 Token firstToken = \_expressionRPN.Peek();
1013                 var evaluationStack = \textcolor{keyword}{new} Stack<Expression>();
1014                 \textcolor{keywordflow}{while} (\_expressionRPN.Count > 0) \{
1015 
1016                     var next = \_expressionRPN.Dequeue();
1017                     \textcolor{keywordflow}{if} (Operator.IsOperator(next.type)) \{
1018 
1019                         \textcolor{comment}{// This is an operation}
1020 
1021                         var info = Operator.InfoForOperator(next.type);
1022                         \textcolor{keywordflow}{if} (evaluationStack.Count < info.arguments) \{
1023                             \textcolor{keywordflow}{throw} ParseException.Make(next, \textcolor{stringliteral}{"Error parsing expression: not enough "} +
1024                                 \textcolor{stringliteral}{"arguments for operator "}+next.type.ToString());
1025                         \}
1026 
1027                         var \hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters} = \textcolor{keyword}{new} List<Expression> ();
1028 
1029                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < info.arguments; i++) \{
1030                             parameters.Add (evaluationStack.Pop ());
1031                         \}
1032                         parameters.Reverse ();
1033 
1034                         var operatorFunc = p.library.GetFunction (next.type.ToString());
1035 
1036                         var expr = \textcolor{keyword}{new} \hyperlink{a00080_a17e5101d02b96d0071e7a0223e4daa3d}{Expression} (\hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, operatorFunc, 
      \hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters}, p);
1037 
1038                         evaluationStack.Push(expr);
1039                     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (next.type == \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType}.Identifier) \{
1040                         \textcolor{comment}{// This is a function call}
1041 
1042                         FunctionInfo info = null;
1043 
1044                         \textcolor{comment}{// If we have a library, use it to check if the}
1045                         \textcolor{comment}{// number of parameters provided is correct}
1046                         \textcolor{keywordflow}{if} (p.library != null) \{
1047                             info = p.library.GetFunction(next.value as \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeacea27118326006d3829667a400ad23d5d98}{String});
1048 
1049                             \textcolor{comment}{// Ensure that this call has the right number of params}
1050                             \textcolor{keywordflow}{if} (info.IsParameterCountCorrect(next.parameterCount) == \textcolor{keyword}{false}) \{
1051                                 \textcolor{keywordtype}{string} error = string.Format(\textcolor{stringliteral}{"Error parsing expression: "} +
1052                                     \textcolor{stringliteral}{"Unsupported number of parameters for function \{0\} (expected \{1\}, got
       \{2\})"},
1053                                     next.value as \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeacea27118326006d3829667a400ad23d5d98}{String},
1054                                     info.paramCount,
1055                                     next.parameterCount
1056                                 );
1057                                 \textcolor{keywordflow}{throw} ParseException.Make(next, error);
1058                             \}
1059                         \} \textcolor{keywordflow}{else} \{
1060                             \textcolor{comment}{// Use a dummy FunctionInfo to represent info about the}
1061                             \textcolor{comment}{// fact that a function is called; note that}
1062                             \textcolor{comment}{// attempting to call this will fail}
1063                             info = \textcolor{keyword}{new} FunctionInfo (next.value, next.parameterCount, (
      \hyperlink{a00029_ae0be2e5cf13d5779816102439e61ff1a}{Function})null);
1064                         \}
1065 
1066 
1067                         var parameterList = \textcolor{keyword}{new} List<Expression> ();
1068                         \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < next.parameterCount; i++) \{
1069                             parameterList.Add (evaluationStack.Pop());
1070                         \}
1071                         parameterList.Reverse ();
1072 
1073                         var expr = \textcolor{keyword}{new} \hyperlink{a00080_a17e5101d02b96d0071e7a0223e4daa3d}{Expression} (\hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, info, parameterList, p);
1074 
1075                         evaluationStack.Push (expr);
1076 
1077                     \} \textcolor{keywordflow}{else} \{
1078 
1079                         \textcolor{comment}{// This is a raw value}
1080                         var v = \textcolor{keyword}{new} ValueNode(\hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, next, p);
1081                         \hyperlink{a00080_a17e5101d02b96d0071e7a0223e4daa3d}{Expression} expr = \textcolor{keyword}{new} \hyperlink{a00080_a17e5101d02b96d0071e7a0223e4daa3d}{Expression}(
      \hyperlink{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{parent}, v, p);
1082                         evaluationStack.Push(expr);
1083 
1084                     \}
1085                 \}
1086                 \textcolor{comment}{// We should now have a single expression in this stack, which is the root}
1087                 \textcolor{comment}{// of the expression's tree. If we have more than one, then we have a problem.}
1088                 \textcolor{keywordflow}{if} (evaluationStack.Count != 1) \{
1089                     \textcolor{keywordflow}{throw} ParseException.Make(firstToken, \textcolor{stringliteral}{"Error parsing expression "} +
1090                         \textcolor{stringliteral}{"(stack did not reduce correctly)"});
1091                 \}
1092 
1093                 \textcolor{comment}{// Return it}
1094                 \textcolor{keywordflow}{return} evaluationStack.Pop ();
1095 
1096 
1097             \}
\end{DoxyCode}
\hypertarget{a00080_a509ba6d93218203bae56a5a7a82e8261}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Print\-Tree@{Print\-Tree}}
\index{Print\-Tree@{Print\-Tree}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Print\-Tree}]{\setlength{\rightskip}{0pt plus 5cm}override string Yarn.\-Parser.\-Expression.\-Print\-Tree (
\begin{DoxyParamCaption}
\item[{int}]{indent\-Level}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [virtual]}}}\label{a00080_a509ba6d93218203bae56a5a7a82e8261}


Implements \hyperlink{a00120_a0d6611653f20c2e4d90a97a96c657137}{Yarn.\-Parser.\-Parse\-Node}.


\begin{DoxyCode}
1129             \{
1130                 var stringBuilder = \textcolor{keyword}{new} StringBuilder ();
1131                 \textcolor{keywordflow}{switch} (\hyperlink{a00080_ad55c92df835006328bc2a79a8f91efb9}{type}) \{
1132                 \textcolor{keywordflow}{case} Type.Value:
1133                     \textcolor{keywordflow}{return} value.PrintTree (indentLevel);
1134                 \textcolor{keywordflow}{case} Type.FunctionCall:
1135                     
1136                     \textcolor{keywordflow}{if} (\hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters}.Count == 0) \{
1137                         stringBuilder.Append(\hyperlink{a00121_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"Function call to "} + \textcolor{keyword}{function}.name + \textcolor{stringliteral}{"
       (no parameters)"}));
1138                     \} \textcolor{keywordflow}{else} \{
1139                         stringBuilder.Append(\hyperlink{a00121_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"Function call to "} + \textcolor{keyword}{function}.name + \textcolor{stringliteral}{" ("}
       +\hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters}.Count+\textcolor{stringliteral}{" parameters) \{"}));
1140                         \textcolor{keywordflow}{foreach} (var param \textcolor{keywordflow}{in} \hyperlink{a00080_a7b21380bead8ae08b2cfc6594edab32c}{parameters}) \{
1141                             stringBuilder.Append(param.PrintTree(indentLevel+1));
1142                         \}
1143                         stringBuilder.Append(\hyperlink{a00121_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"\}"}));
1144                     \}
1145                     \textcolor{keywordflow}{return} stringBuilder.ToString();
1146 
1147 
1148                 \}
1149 
1150                 \textcolor{keywordflow}{return} \hyperlink{a00121_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab}(indentLevel, \textcolor{stringliteral}{"<error printing expression!>"});
1151             \}
\end{DoxyCode}
\hypertarget{a00080_a5004a8eaa00b2b55856ecb4f339033fb}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Should\-Apply\-Precedence@{Should\-Apply\-Precedence}}
\index{Should\-Apply\-Precedence@{Should\-Apply\-Precedence}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Should\-Apply\-Precedence}]{\setlength{\rightskip}{0pt plus 5cm}static bool Yarn.\-Parser.\-Expression.\-Should\-Apply\-Precedence (
\begin{DoxyParamCaption}
\item[{{\bf Token\-Type}}]{o1, }
\item[{Stack$<$ {\bf Token} $>$}]{operator\-Stack}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}}\label{a00080_a5004a8eaa00b2b55856ecb4f339033fb}

\begin{DoxyCode}
1101                                                                                                 \{
1102                 
1103                 \textcolor{keywordflow}{if} (operatorStack.Count == 0) \{
1104                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1105                 \}
1106                 \textcolor{keywordflow}{if} (Operator.IsOperator (o1) == \textcolor{keyword}{false}) \{
1107                     \textcolor{keywordflow}{throw} \textcolor{keyword}{new} ParseException (\textcolor{stringliteral}{"Internal error parsing expression"});
1108                 \}
1109                 \hyperlink{a00029_a301aa7c866593a5b625a8fc158bbeace}{TokenType} o2 = operatorStack.Peek ().\hyperlink{a00080_ad55c92df835006328bc2a79a8f91efb9}{type};
1110 
1111                 \textcolor{keywordflow}{if} (Operator.IsOperator (o2) == \textcolor{keyword}{false})
1112                     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1113 
1114                 var o1Info = Operator.InfoForOperator (o1);
1115                 var o2Info = Operator.InfoForOperator (o2);
1116 
1117                 \textcolor{keywordflow}{if} (o1Info.associativity == Operator.Associativity.Left && o1Info.precedence <= o2Info.
      precedence) \{
1118                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1119                 \}
1120 
1121                 \textcolor{keywordflow}{if} (o1Info.associativity == Operator.Associativity.Right && o1Info.precedence < o2Info.
      precedence) \{
1122                     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1123                 \}
1124 
1125                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1126             \}
\end{DoxyCode}
\hypertarget{a00120_a054f36c80d5eeacd569a8859f599af67}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!Tags\-To\-String@{Tags\-To\-String}}
\index{Tags\-To\-String@{Tags\-To\-String}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{Tags\-To\-String}]{\setlength{\rightskip}{0pt plus 5cm}string Yarn.\-Parser.\-Parse\-Node.\-Tags\-To\-String (
\begin{DoxyParamCaption}
\item[{int}]{indent\-Level}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}}\label{a00120_a054f36c80d5eeacd569a8859f599af67}

\begin{DoxyCode}
122             \{
123                 \textcolor{keywordflow}{if} (\hyperlink{a00120_a58b3a15788fd2d4127d73619dc6d04ae}{tags}.Length > 0) \{
124                     var s = \textcolor{keyword}{new} StringBuilder ();
125 
126                     s.Append (\hyperlink{a00121_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab} (indentLevel + 1, \textcolor{stringliteral}{"Tags:"}));
127                     \textcolor{keywordflow}{foreach} (var tag \textcolor{keywordflow}{in} this.\hyperlink{a00120_a58b3a15788fd2d4127d73619dc6d04ae}{tags}) \{
128                         s.Append(\hyperlink{a00121_aa8fa36b46de12a1c561d77b99c4b9ae3}{Tab} (indentLevel + 2, \textcolor{stringliteral}{"#"} + tag));
129                     \}
130                     \textcolor{keywordflow}{return} s.ToString ();
131                 \} \textcolor{keywordflow}{else} \{
132                     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
133                 \}
134 
135 
136             \}
\end{DoxyCode}
\hypertarget{a00120_a18c67cb16090d0889bb9d6c8c6c565f8}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!To\-String@{To\-String}}
\index{To\-String@{To\-String}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{To\-String}]{\setlength{\rightskip}{0pt plus 5cm}override string Yarn.\-Parser.\-Parse\-Node.\-To\-String (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inherited]}}}\label{a00120_a18c67cb16090d0889bb9d6c8c6c565f8}

\begin{DoxyCode}
139             \{
140                 \textcolor{keywordflow}{return} this.GetType ().Name;
141             \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\hypertarget{a00080_a9c1859ce5ad4c86ded8dd0d61da61320}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!function@{function}}
\index{function@{function}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{function}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Function\-Info} Yarn.\-Parser.\-Expression.\-function\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_a9c1859ce5ad4c86ded8dd0d61da61320}
\hypertarget{a00120_a18b493382de0fde5b4299c1bd2250075}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!line\-Number@{line\-Number}}
\index{line\-Number@{line\-Number}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{line\-Number}]{\setlength{\rightskip}{0pt plus 5cm}int Yarn.\-Parser.\-Parse\-Node.\-line\-Number\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [inherited]}}}\label{a00120_a18b493382de0fde5b4299c1bd2250075}
\hypertarget{a00080_a7b21380bead8ae08b2cfc6594edab32c}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!parameters@{parameters}}
\index{parameters@{parameters}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{parameters}]{\setlength{\rightskip}{0pt plus 5cm}List$<${\bf Expression}$>$ Yarn.\-Parser.\-Expression.\-parameters\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_a7b21380bead8ae08b2cfc6594edab32c}
\hypertarget{a00120_af313a82103fcc2ff5a177dbb06b92f7b}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!parent@{parent}}
\index{parent@{parent}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{parent}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parse\-Node} Yarn.\-Parser.\-Parse\-Node.\-parent\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [inherited]}}}\label{a00120_af313a82103fcc2ff5a177dbb06b92f7b}
\hypertarget{a00120_a58b3a15788fd2d4127d73619dc6d04ae}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!tags@{tags}}
\index{tags@{tags}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{tags}]{\setlength{\rightskip}{0pt plus 5cm}string \mbox{[}$\,$\mbox{]} Yarn.\-Parser.\-Parse\-Node.\-tags = \{\}\hspace{0.3cm}{\ttfamily [package]}, {\ttfamily [inherited]}}}\label{a00120_a58b3a15788fd2d4127d73619dc6d04ae}
\hypertarget{a00080_ad55c92df835006328bc2a79a8f91efb9}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!type@{type}}
\index{type@{type}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{type}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Type} Yarn.\-Parser.\-Expression.\-type\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_ad55c92df835006328bc2a79a8f91efb9}
\hypertarget{a00080_a569e516782891544c334ff8131b23108}{\index{Yarn\-::\-Parser\-::\-Expression@{Yarn\-::\-Parser\-::\-Expression}!value@{value}}
\index{value@{value}!Yarn::Parser::Expression@{Yarn\-::\-Parser\-::\-Expression}}
\subsubsection[{value}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Value\-Node} Yarn.\-Parser.\-Expression.\-value\hspace{0.3cm}{\ttfamily [package]}}}\label{a00080_a569e516782891544c334ff8131b23108}


The documentation for this class was generated from the following file\-:\begin{DoxyCompactItemize}
\item 
Yarn\-Spinner/\hyperlink{a00266}{Parser.\-cs}\end{DoxyCompactItemize}
